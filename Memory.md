1. 프로그램 메모리 구조
  ![image](https://user-images.githubusercontent.com/38064756/121796114-aa821080-cc51-11eb-852d-3fb211679604.png)
  Reference:https://velog.io/@cchloe2311/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0

  위 그림에서 확인할 수 있듯이 프로세스는 기본적으로 Code, Data, Heap, Stack 4 영역으로 구분된다.
  - Stack : 지역 변수, 매개 변수, Return 주소값을 저장한다.
            컴파일 타임할 때 메모리 크기가 결정되어 할당된다. 따라서, 매 실행시 마다 동일한 메모리 크기를 가진다 -> 동적으로 변경 불가능하다.
            EX) int Array[100]; <- 이 처럼 변수 선언시 얼마만큼의 메모리를 사용할지 알고 있을 때 사용
            ![image](https://user-images.githubusercontent.com/38064756/121797039-9261bf80-cc58-11eb-8e00-6ff72ac14a10.png)
            
  - Heap : 매 실행시 혹은 프로그램을 실행하면서 해당 변수가 가지는 메모리의 크기가 가변적일 때 할당되는 메모리 영역이다.
            C++에서는 new, delete 키워드로 관리한다.
            Stack 구조와는 다르게 메모리 할당을 실행한 코드 영역을 벗어나도 메모리가 해제되지 않기 때문에 사용하지 않는 메모리는 해제해주어야 리소스 낭비를 줄일 수 있다.
            JAVA, Python은 기본적으로 GC를 주기적으로 실행하여 Reference가 불가능한 메모리에 대해서 할당을 해준다.
            하지만 C++은 GC 기능을 제공하지 않는다. 이를 보완하기 위해 RAII(=Resource Acquisition Is Initialization) 디자인 패턴을 도입하였다.
            RAII는 메모리 할당 및 해제를 클래스의 생성자와 소멸자에 선언해줌으로써, 해당 객체가 소멸될 때 소멸자에 의해서 메모리를 해제해주도록 하는 패턴이다.
     
  - Data : Static 변수, 전역 변수 등이 저장되는 곳이다. 초기 값이 할당되지 않는 경우 0으로 할당된다.
  - Code : 프로그래머가 작성한 Code가 저장되는 영역.
  
2. 프로그램이 실행되는 과정.
  - 컴파일 과정 : 전처리(#define, #include 내용 대입, .i) -> 컴파일러(C->어셈블리어, .s) -> 어셈블러(어셈블리->기계어, .o) -> Linker(기계어 파일을 묶어서 실행가능한 파일로 만든다)
    *정적 링크 : 실행파일을 만들 때 해당 라이브러리를 파일에 포함한다. -> 특정 라이브러리를 여러 프로그램에서 참조할 경우 중복되므로 비효율적
    *동적 링크 : 프로세스가 실행하면서 특정 라이브러리를 이용할 때 해당 메소드를 RAM에 올리게 된다. 여러 프로그램이 해당 메소드를 사용할 경우 공유할 수 있으므로 메모리면에서 효율적이다.
  - 프로그램 실행 요청 -> IO 작업을 통해서 일정량의 Page를 Memory에 적재한다.(올라가는 Page의 양은 OS 규칙에 따라 다를 수 있다.) -> 프로그램을 실행하면 계속해서 Page를 요청

3. Paging 기법
  - Paging : 프로그램을 일정량의 단위로 잘라서 관리하는 방법. (주메모리의 FRAME크기와 프로그램의 PAGE크기는 일치하여야 한다.)
  - 등장 배경 : 일반적으로 컴퓨터는 4gb~16gb로 구성된 메인메모리를 갖는다. 만약 프로그램을 실행할 때 프로그램 전체를 메인 메모리에 올린다면 메인 메모리는 금방 고갈될 것이다. 또한, 5GB의 메인메모리가 남아있을 때 6GB의 프로그램을 실행시키려 하면 메모리 용량이 부족하여 5GB라는 큰 크기의 외부 단편화가 발생한다. 이 뿐만아니라, 프로그램 실행 시 일반적으로 모든 데이터를 고르게 사용하기 보다는 일부 영역의 데이터를 집중적으로 활용하게 되는데 이럴 경우 실질적으로 사용되지 않는 데이터로 인해 메인 메모리가 낭비된다.
  - Paging 기법은 이와같은 문제를 해결하고 제한된 메인 메모리를 효율적으로 사용할 수 있다.
  - 모든 프로그램은 고유의 Pagetable을 갖는다. pagetable에는 논리 주소와 실제 주소에 대한 mapping 자료를 가지고 있고, 프로그램 실행 시 메인 메모리에 적재된다.
  - 페이지 참조 과정 : 
    CPU가 특정 논리 주소를 참조 -> TLB Hit -> 곧장 실제 Frame 주소를 얻고 참조 (RAM Access = 1회)
                                 TLB Miss -> Ram에 적재된 Pagetable 참조 -> 해당 Page의 valid vit == 1 -> 메인 메모리 주소 획득 -> 해당 주소 참조 (RAM Access = 2회)
                                                                        -> valid vit ==0 -> IO Interrupt -> RAM 적재 -> valid vit = 1 -> 위 과정 수행.
   *실제 frame 주소를 얻고 해당 주소를 참조하려 할 때 cache에 저장되어 있다면 RAM에 접근할 필요 없이 바로 데이터를 얻을 수 있다.
   
  
