Process : 운영체제에서 자원을 할당 받아 실행중인 프로그램

생성과정 : 프로그램 실행요청 -> PCB(PC, Register, PID, Process State, Process 스케줄링 우선순위 값 등) 초기화, 일부 메모리(Code, Data, Heap, Stack RAM) 에 적재( RAM에 전부 다 올리지 않는 이유는 Demand paging 기법을 활용하여 제한된 RAM 자원을 효울적으로 사용하기 위해서이다. Swap paging 기법과 더불어 사용하여 메모리 용량보다 큰 용량의 프로그램을 동시에 실행할 수 있게 된다.)
-> Ready Queue에 등록 후 운영체제에 의해 스케줄링 된다.

특징 : 각 프로세스 별로 독립된 메모리 구조를 갖는다.
      1개 이상의 Thread를 가지고 있다.
      CPU로 부터 자원을 할당 받는 주체이다.
      프로세스간 통신(IPC)을 위한 방법으로는 메시지 큐, 공유 메모리를 활용한 방법과 소켓 통신 방법이 있다. ** 공유 메모리를 사용하는 경우 쓰기 작업이 실행될 때 데이터 동기화를 해줘야 한다( ex, 멀티 쓰레드 환경)
 
Thread : 프로세스의 실행 단위

특징 : 기본적으로 프로세스당 1개 이상의 Thread가 존재하고, 프로세스에 의해 추가적으로 생성될 수 있다.
      각 Threads는 PCB, HEAP, DATA, CODE 영역을 다른 Threads와 공유한다. (Program Counter와 Stack은 독립적) PC-> Thread 별로 독립된 실행을 가진다, Stack은 실행흐름에서 지역변수, 함수 콜스택 등을 저장한다. -> 독립 Stack, PC Register -> 독립 실행 흐름 가능
      다른 Threads들과 메모리를 공유하기 때문에 통신이 빠르지만, 동일한 메모리에서 쓰기 작업을 할 경우 비 정상적인 결과 값이 나올 수 있으므로 Semaphore나 Lock을 활용하여 Critical Section을 설정하고 동시에 동일한 메모리에 작업하지 못하도록 해야한다. 또는 Atomic 키워드를 활용하여 명령어 실행시 매 번 메모리에서 읽고 쓰는 작업을 단위화 하여 해결 가능하다.
      멀티 스레드 방식은 Context Switching과 스레드 생성 및 종료 cost가 Process보다 적어 효율성에서는 멀티 프로세스보다 뛰어나다. 하지만, 실행 순서를 예측하기 어렵고 동일한 메모리에 대해서 읽기, 쓰기 작업을 2개 이상의 Thread가 실행할 경우 Race Condition과 Out of Order Execution 문제를 고려하여 동기화 작업을 해주어야 한다.
        - Race Condition이란 동일한 자원에 대해서 병행적으로(concurrently) 읽거나 쓰는 동작을 할 때, 공용 데이터에 대한 접근이 어떤 순서에 따라 이루어졌는지에 따라 그 실행 결과가 같지 않고 달라지는 상황을 말한다.
        - Out Of Order Execution이란 프로그래머의 코드를 컴파일러와 CPU의 최적화 작업으로 인해서 코드의 실행순서가 달라지게 되고 이로 인해서 예측과 다른 결과값을 가지게 된다.
          컴파일러에 의한 최적화 작업은 단순히 volatile 키워드를 사용하면 해결할 수 있다. 하지만, volatile을 사용하더라도 CPU에 의한 최적화 작업으로 인해 결과값이 달라질 수 있다.
          대표적으로, Lock 기법을 사용한 코드를 예시로 들면
         void func1()
         {
          a=0;
          b=0;
          x=0;
          a=20;
          x+=10;
          b=30;
          }
          void func2()
          {
            print("%d, %d, %d",a,x,b);
          }
          위의 코드에서 CPU는 해당 x+=10; 보다 a=20 명령어를 먼저 실행 시킬 수도 있고 b=30; 보다 x+=10 을 먼저 실행시킬 수도 있다. (두 명령어 간에 의존 관계가 없기 떄문).
          1. 단일 Thread 환경 -> 항상 단일 Core에서 실행되므로 CPU가 Reorder beffer를 활용하여 명령어 실행 "완료: 순서를 동기화 시켜주어 결국 프로그램은 순차적으로 실행되는 것과 동일한 결과 값을 갖게된다.
                              - 만약 x+=10;을 먼저 실행한 스레드가 있을 경우에도 파이프라이닝 단계에서 update값을 forwarding 해주기 때문에 값은 동기화 된다.
          2. 다중 Thread 환경 -> 여러 Core에 나눠져 여러 스레드가 동시에 실행가능하다. 따라서, 출력값이 다를 수 있다. (20,0,0 or 20,10,30 or 20,0,30 ....)
                                이를 동기화 하기위해 Memory Order Macro를 사용할 수 있다.
